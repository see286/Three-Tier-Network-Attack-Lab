# vulnerability-design

This project implements a three‑layer network penetration lab with deliberate vulnerability deployment.

It constructs SSH weak password, Redis unauthorized access, and Flask SSTI vulnerabilities in a multi‑host scenario.

It enables persistent services and reverse port forwarding for complete multi‑hop penetration simulation.

-------

在漏洞构造的过程中，我们首先需要明确我们漏洞构造的位置，我们需要实现一个分层渗透：由攻击机到代理机实现第一跳然后再由代理机攻入内网，我们需要在代理机和内网机分别放置漏洞，最后在内网机放置flag并找到flag。

在所有可选漏洞中，我最终选定了代理机放置弱口令SSH和Redis未授权访问，而内网机我最终选定了Flask SSTI漏洞，下面我将分别详细讲讲漏洞的构造。

### 代理机漏洞构造

#### 漏洞1——弱口令SSH

首先我们需要在代理机上创建一个弱口令用户作为攻击入口，实现口令如下：

```bash
sudo useradd -m -s /bin/bash student
echo "student:students" | sudo chpasswd
```

这是一个极容易被爆破的弱口令，用户名是student，密码是students，我将在下面对该命令作详细解释：

首先“useradd”即创建新用户，-m是自动创建用户家所在目录，-s /bin/bash是指定用户使用bash作为登录的shell，“chpasswd”表明通过chpasswd批量格式来设置用户密码

如果ssh保持打开状态，用户即可以使用ssh登录。

**持久化设计：**我们需要在代理机上执行来确保SSH服务长期开启：

```bash
sudo systemctl enable ssh
sudo systemctl start ssh
```

其中enable保证了开机自动开启，start确保了ssh服务当下立即开启

#### 漏洞2——Redis弱口令漏洞

我首先安装了Redis但未设置密码：

```bash
sudo apt install -y redis-server
```

然后我又将Redis配置设为允许外网访问，最终Redis运行的状态如下：

![image-20251127144842927](D:\LJY\Github\Three-Tier-Network-Attack-Lab\images\image-20251127144842927.png)

在实验中默认是0.0.0.0监听。

Redis由于没有设密码，对所有的IP都可以开放，攻击者无需密码即可直接获取Redis权限，属于典型的未访问授权。

有了该权限后就可以实现像SSH公钥提权、清楚数据、注入恶意配置甚至获取系统信息等行为

**持久化设计：**Redis安装后默认是实现systemed自启的，但是我在关机后再开机发现我的系统出现报错，systemed不可用，因此我没办法用systemctl管理服务，所有我还需要用别的方法给该漏洞做永久化：

```nginx
sudo crontab -e
```

```bash
@reboot /usr/bin/redis-server --daemonize yes
```

我最后选择了使用cron@reboot来对其作永久化，开机后@reboot脚本会生效，确保了漏洞2的开启

### 内网机漏洞构造

本次实验漏洞构造的重点应该还是在内网构造的一个可被攻击机利用的Flask模板注入(SSTI)漏洞，并且在代理机通过socat建立反向的转发使得攻击机在外网环境依然能够访问内网的漏洞服务

我在这里先解释一下SSTI漏洞吧：SSTI是一种服务器端模板注入漏洞，发生在应用程序使用模板引擎渲染用户输入时。攻击者能够注入恶意模板代码，在服务器端执行任意代码。

其实也就是将用户输入与模板代码相混合，导致用户的输入被当作代码执行，只有严格严格分离代码和数据，对用户输入进行适当的转义和过滤才能输出正确指令，算是比较难缠的一个漏洞了吧

#### 漏洞3——Flask SSTI漏洞

##### Flask的安装

由于Flask要装在内网上，而内网又断网了，所以我们需要的Flask没办法在内网下载，我们需要先实现从代理机上下好Flask然后传到内网上

首先我们需要在代理机上面下载Flask及其依赖包(`.whl` 格式):

```bash
mkdir ~/pkgs
cd ~/pkgs
pip download flask
```

pip download这个指令会将Flask所需的所有依赖一并下载下来成.whl包可以复制到内网机离线安装

然后我们需要将这些包复制到内网机，我在该次实验中用的方法是ssh服务：

我首先在内网机启动了ssh服务并且设置了开机自启：

```bash
sudo systemctl start ssh
sudo systemctl enable ssh
sudo systemctl status ssh
```

然后我们在代理机通过ssh用scp将这些文件传到内网机：

```bash
scp ~/pkgs/* kali@192.168.3.10:/home/kali/
```

接下来我们就需要在内网中完成剩余操作了，内网机虽然没办法上网，但是系统自带python，我们可以用python来创建独立的虚拟环境：

```bash
python3 -m venv ~/flaskenv
source ~/flaskenv/bin/activate
```

这两个命令首先创建了一个独立的Python 运行环境，避免污染系统 Python，让 Flask 和依赖都装在独立目录中；然后又激活了该虚拟环境，现在我们就可以在内网机离线安装Flask了：

```bash
cd ~/pkgs
pip install *.whl
```

最后我们再运行Flask导入测试来确认Flask是否能正常被 Python 导入：

```bash
Flask OK: 3.1.2
```

到这里，我们Flask的安装就结束了

##### Flask SSTI漏洞的构建

我们首先需要先写一个脆弱的Flask Web服务：

```bash
mkdir ~/vuln_flask
cd ~/vuln_flask
sudo nano app.py
```

内容见`vulns/flask-app/app.py`

然后我们让该靶机服务运行也就算好啦：

```bash
cd ~/vuln_flask
source ~/flaskenv/bin/activate
python3 app.py
```

**持久化设计：**我们要实现内网机Flask服务的开机自启实际上方法也很多，我最后选择的是创建systemed服务实现开机自启：

```swift
sudo nano /etc/systemd/system/vuln-flask.service
```

```ini
[Unit]
Description=Vulnerable Flask Server
After=network.target

[Service]
User=kali
WorkingDirectory=/home/kali/vuln_flask
ExecStart=/home/kali/flaskenv/bin/python3 app.py
Restart=always

[Install]
WantedBy=multi-user.target
```

然后开启该服务：

```sql
sudo systemctl daemon-reload
sudo systemctl enable vuln-flask
sudo systemctl start vuln-flask
```

验证该服务是否开启：

```lua
sudo systemctl status vuln-flask
```

![image-20251127165741825](D:\LJY\Github\Three-Tier-Network-Attack-Lab\images\image-20251127165741825.png)

##### 代理机使用socat反向端口转发

由于靶机位于内网，其 8080 端口对外不可访问。为了让攻击机能够访问靶机的易受攻击 Flask 服务，我在代理机上使用 socat 将代理机的 8080 端口转发至靶机的 5000 端口：

```bash
socat TCP-LISTEN:8080,fork TCP:192.168.3.10:5000
```

使用了该命令后，代理机会监听自己的8080端口并且将所有访问该端口的流量全部代转发到靶机的5000端口上

这其实也就是将我们的内网服务暴露在了外网，如果我们不在代理机上进行反向转发操作，攻击机curl该端口后就会直接超时，因为靶机是内网隔离。

**持久化设计：**同样地，上面那条指令也就是一个即时指令，要想让代理机每次开机都自动转发该漏洞端口，我也是创建了systemed端口：

```bash
sudo nano /etc/systemd/system/socat-proxy.service
```

```ini
[Unit]
Description=TCP proxy from 192.168.2.10:8080 to 192.168.3.10:5000
After=network.target

[Service]
ExecStart=/usr/bin/socat TCP-LISTEN:8080,fork TCP:192.168.3.10:5000
Restart=always
User=root

[Install]
WantedBy=multi-user.target
```

然后我们还是开启该服务：

```bash
sudo systemctl daemon-reload
sudo systemctl enable socat-proxy
sudo systemctl start socat-proxy
```

验证该服务是否开启：

```lua
sudo systemctl status socat-proxy
sudo ss -tlnp | grep 8080
```

![image-20251127173855390](D:\LJY\Github\Three-Tier-Network-Attack-Lab\images\image-20251127173855390.png)

到这里，我们漏洞的构造就完全实现了！

### 关于flag

实际上，在本次实验中，我设置了两个flag，一个在代理机一个在内网机，攻击者需要分别拿到代理机和内网机的flag

代理机的漏洞比较好进flag也比较好找，在此我设置如下：

```bash
 echo "moectf{proxy_first_compromise}" | sudo tee /root/proxy_flag.txt
 chown student:student /home/student/proxy_flag.txt
chmod 644 /home/student/proxy_flag.txt
```

我顺便给flag提了个权使得其变成了可读文件方便操作

在完成代理机漏洞和内网 Flask SSTI 服务搭建后，我在内网靶机上放置了本次实验的最终目标 —— flag，flag我在内网放置了名为flag.txt的文件，攻击者主要渗透进内网找到flag就能拿到flag的内容：

```bash
cd ~/vuln_flask
echo "moectf{ssti_success_2025}" > flag.txt
cat flag.txt
```

